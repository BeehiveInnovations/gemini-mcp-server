/**
 * Test Runner Service for Grunts LLM-generated code
 * Executes tests against code generated by competing LLMs
 */

const express = require('express');
const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const chokidar = require('chokidar');
const WebSocket = require('ws');

const app = express();
const PORT = 8080;
const WORKSPACE_PATH = '/workspace';
const RESULTS_PATH = '/results';

// Test metrics storage
let testMetrics = {
  totalTests: 0,
  passedTests: 0,
  failedTests: 0,
  coverage: 0,
  lastRun: null,
  testSuites: {}
};

app.use(express.json());

/**
 * API Routes
 */

// Get current test metrics
app.get('/api/metrics', (req, res) => {
  res.json(testMetrics);
});

// Run tests for a specific worker/task
app.post('/api/test/:taskId/:workerId', async (req, res) => {
  try {
    const { taskId, workerId } = req.params;
    const { framework = 'jest' } = req.body;
    
    console.log(`🧪 Running tests for ${taskId}/${workerId} using ${framework}`);
    
    const workspacePath = path.join(WORKSPACE_PATH, taskId, workerId);
    const results = await runTests(workspacePath, framework);
    
    // Update metrics
    updateTestMetrics(workerId, results);
    
    res.json({
      success: true,
      results,
      metrics: testMetrics.testSuites[workerId] || {}
    });
    
  } catch (error) {
    console.error('Test execution error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get test results for a worker
app.get('/api/results/:workerId', async (req, res) => {
  try {
    const { workerId } = req.params;
    const resultsFile = path.join(RESULTS_PATH, `${workerId}-results.json`);
    
    const results = await fs.readFile(resultsFile, 'utf8');
    res.json(JSON.parse(results));
    
  } catch (error) {
    res.status(404).json({ error: 'Results not found' });
  }
});

/**
 * Test execution functions
 */

async function runTests(workspacePath, framework = 'jest') {
  const testResults = {
    framework,
    startTime: Date.now(),
    endTime: null,
    passed: 0,
    failed: 0,
    total: 0,
    coverage: 0,
    errors: [],
    details: []
  };
  
  try {
    // Check if workspace exists and has test files
    const hasTests = await checkForTests(workspacePath);
    
    if (!hasTests) {
      // Generate basic tests if none exist
      await generateBasicTests(workspacePath);
    }
    
    // Run tests based on framework
    const result = await executeTestFramework(workspacePath, framework);
    
    testResults.endTime = Date.now();
    testResults.duration = testResults.endTime - testResults.startTime;
    testResults.passed = result.passed;
    testResults.failed = result.failed;
    testResults.total = result.total;
    testResults.coverage = result.coverage;
    testResults.errors = result.errors;
    testResults.details = result.details;
    
    console.log(`✅ Tests completed: ${result.passed}/${result.total} passed`);
    
  } catch (error) {
    testResults.endTime = Date.now();
    testResults.errors.push(error.message);
    console.error('Test execution failed:', error);
  }
  
  return testResults;
}

async function checkForTests(workspacePath) {
  try {
    const files = await fs.readdir(workspacePath);
    return files.some(file => 
      file.includes('.test.') || 
      file.includes('.spec.') || 
      file.startsWith('test_')
    );
  } catch (error) {
    return false;
  }
}

async function generateBasicTests(workspacePath) {
  console.log('📝 Generating basic tests...');
  
  try {
    // Find JavaScript/TypeScript files to test
    const files = await fs.readdir(workspacePath);
    const codeFiles = files.filter(file => 
      file.endsWith('.js') || file.endsWith('.ts') && !file.includes('.test.')
    );
    
    for (const file of codeFiles) {
      const testFileName = file.replace(/\.(js|ts)$/, '.test.js');
      const testContent = generateTestTemplate(file);
      
      await fs.writeFile(
        path.join(workspacePath, testFileName),
        testContent,
        'utf8'
      );
    }
    
    // Create package.json if it doesn't exist
    const packagePath = path.join(workspacePath, 'package.json');
    try {
      await fs.access(packagePath);
    } catch {
      const packageContent = {
        name: "grunts-generated-code",
        version: "1.0.0",
        scripts: {
          test: "jest",
          "test:vitest": "vitest"
        },
        devDependencies: {
          jest: "^29.7.0",
          vitest: "^1.0.0"
        }
      };
      
      await fs.writeFile(packagePath, JSON.stringify(packageContent, null, 2));
    }
    
  } catch (error) {
    console.error('Error generating tests:', error);
  }
}

function generateTestTemplate(fileName) {
  const moduleName = path.basename(fileName, path.extname(fileName));
  
  return `// Auto-generated test for ${fileName}
const { ${moduleName} } = require('./${fileName}');

describe('${moduleName}', () => {
  test('should be defined', () => {
    expect(${moduleName}).toBeDefined();
  });
  
  test('should handle basic functionality', () => {
    // Basic smoke test
    if (typeof ${moduleName} === 'function') {
      expect(typeof ${moduleName}).toBe('function');
    } else {
      expect(typeof ${moduleName}).toBe('object');
    }
  });
  
  test('should handle edge cases', () => {
    // Test with null/undefined
    if (typeof ${moduleName} === 'function') {
      try {
        ${moduleName}(null);
        ${moduleName}(undefined);
        expect(true).toBe(true); // If no error thrown
      } catch (error) {
        expect(error).toBeInstanceOf(Error); // Error handling is acceptable
      }
    }
  });
});
`;
}

async function executeTestFramework(workspacePath, framework) {
  return new Promise((resolve, reject) => {
    const command = framework === 'vitest' ? 'vitest' : 'jest';
    const args = framework === 'vitest' ? ['run'] : ['--json'];
    
    const testProcess = spawn(command, args, {
      cwd: workspacePath,
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    let stdout = '';
    let stderr = '';
    
    testProcess.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    
    testProcess.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    testProcess.on('close', (code) => {
      try {
        let results = {
          passed: 0,
          failed: 0,
          total: 0,
          coverage: 0,
          errors: [],
          details: []
        };
        
        if (framework === 'jest' && stdout) {
          // Parse Jest JSON output
          const jestResults = JSON.parse(stdout);
          results.passed = jestResults.numPassedTests || 0;
          results.failed = jestResults.numFailedTests || 0;
          results.total = jestResults.numTotalTests || 0;
          results.coverage = jestResults.coverageMap ? 50 : 0; // Mock coverage
        } else {
          // Parse basic output for other frameworks
          const lines = stdout.split('\\n');
          results.total = lines.filter(line => line.includes('✓') || line.includes('✗')).length;
          results.passed = lines.filter(line => line.includes('✓')).length;
          results.failed = results.total - results.passed;
        }
        
        if (stderr) {
          results.errors.push(stderr);
        }
        
        resolve(results);
      } catch (error) {
        resolve({
          passed: 0,
          failed: 1,
          total: 1,
          coverage: 0,
          errors: [error.message, stderr],
          details: []
        });
      }
    });
    
    testProcess.on('error', (error) => {
      reject(error);
    });
  });
}

function updateTestMetrics(workerId, results) {
  testMetrics.testSuites[workerId] = {
    ...results,
    lastUpdated: Date.now()
  };
  
  // Update totals
  testMetrics.totalTests = Object.values(testMetrics.testSuites)
    .reduce((sum, suite) => sum + suite.total, 0);
  testMetrics.passedTests = Object.values(testMetrics.testSuites)
    .reduce((sum, suite) => sum + suite.passed, 0);
  testMetrics.failedTests = Object.values(testMetrics.testSuites)
    .reduce((sum, suite) => sum + suite.failed, 0);
  testMetrics.lastRun = Date.now();
}

/**
 * File watching for automatic test execution
 */
function startFileWatcher() {
  console.log('👀 Starting file watcher...');
  
  const watcher = chokidar.watch(`${WORKSPACE_PATH}/**/*.{js,ts}`, {
    ignored: /node_modules/,
    persistent: true
  });
  
  watcher.on('change', async (filePath) => {
    const relativePath = path.relative(WORKSPACE_PATH, filePath);
    const [taskId, workerId] = relativePath.split('/');
    
    if (taskId && workerId) {
      console.log(`🔄 File changed: ${relativePath}, running tests...`);
      
      try {
        const workspacePath = path.join(WORKSPACE_PATH, taskId, workerId);
        const results = await runTests(workspacePath, 'jest');
        updateTestMetrics(workerId, results);
        
        // Broadcast update via WebSocket (if connected)
        // broadcastTestUpdate(workerId, results);
        
      } catch (error) {
        console.error('Auto-test execution failed:', error);
      }
    }
  });
}

// Start the server
app.listen(PORT, () => {
  console.log(`🧪 Test Runner Service running on port ${PORT}`);
  startFileWatcher();
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('Shutting down Test Runner Service...');
  process.exit(0);
});